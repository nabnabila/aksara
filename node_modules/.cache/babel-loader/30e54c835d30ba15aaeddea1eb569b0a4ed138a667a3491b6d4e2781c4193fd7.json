{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findCorrectAnswers = exports.deserializeGuesses = exports.loadGuesses = exports.serializeGuesses = exports.saveGuesses = exports.clearGuesses = exports.byNumber = exports.createGridData = exports.fillClues = exports.createEmptyGrid = exports.calculateExtents = exports.otherDirection = exports.isAcross = exports.bothDirections = void 0;\nconst directionInfo = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row'\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col'\n  }\n};\nexports.bothDirections = Object.keys(directionInfo);\nfunction isAcross(direction) {\n  return direction === 'across';\n}\nexports.isAcross = isAcross;\nfunction otherDirection(direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\nexports.otherDirection = otherDirection;\nfunction calculateExtents(data, direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n  Object.entries(data[direction]).forEach(_ref => {\n    let [, info] = _ref;\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n  const rowColMax = {\n    row: 0,\n    col: 0\n  };\n  rowColMax[dir.primary] = primaryMax;\n  rowColMax[dir.orthogonal] = orthogonalMax;\n  return rowColMax;\n}\nexports.calculateExtents = calculateExtents;\n// const emptyCellData: Partial<CellData> = {\n//   used: false,\n//   // number: undefined, // null,\n//   // answer: '',\n//   // guess: '',\n//   // row: r,\n//   // col: c,\n//   // across: '', //null,\n//   // down: '', //null,\n// } as const;\nfunction createEmptyGrid(rows, cols) {\n  const gridData = Array(rows);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < rows; r++) {\n    gridData[r] = Array(cols);\n    for (let c = 0; c < cols; c++) {\n      gridData[r][c] = {\n        // ...emptyCellData,\n        row: r,\n        col: c,\n        used: false\n      };\n    }\n  }\n  return gridData;\n}\nexports.createEmptyGrid = createEmptyGrid;\nfunction fillClues(gridData, clues, data, direction) {\n  const dir = directionInfo[direction];\n  Object.entries(data[direction]).forEach(_ref2 => {\n    let [number, info] = _ref2;\n    const {\n      row: rowStart,\n      col: colStart,\n      clue,\n      answer\n    } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === 'row' ? i : 0);\n      const col = colStart + (dir.primary === 'col' ? i : 0);\n      const cellData = gridData[row][col];\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n    clues[direction].push({\n      number,\n      clue,\n      answer,\n      col: colStart,\n      row: rowStart\n    });\n  });\n  clues[direction].sort(byNumber);\n}\nexports.fillClues = fillClues;\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nfunction createGridData(data, allowNonSquare) {\n  const acrossMax = calculateExtents(data, 'across');\n  const downMax = calculateExtents(data, 'down');\n  let rows = Math.max(acrossMax.row, downMax.row) + 1;\n  let cols = Math.max(acrossMax.col, downMax.col) + 1;\n  if (!allowNonSquare) {\n    const size = Math.max(rows, cols);\n    rows = size;\n    cols = size;\n  }\n  const gridData = createEmptyGrid(rows, cols);\n  // Now fill with answers... and also collect the clues\n  const clues = {\n    across: [],\n    down: []\n  };\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n  return {\n    rows,\n    cols,\n    gridData,\n    clues\n  };\n}\nexports.createGridData = createGridData;\nfunction byNumber(a, b) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n  return aNum - bNum;\n}\nexports.byNumber = byNumber;\nfunction clearGuesses(storageKey) {\n  if (!window.localStorage) {\n    return;\n  }\n  window.localStorage.removeItem(storageKey);\n}\nexports.clearGuesses = clearGuesses;\nfunction saveGuesses(gridData, storageKey) {\n  const {\n    localStorage\n  } = window;\n  if (!localStorage) {\n    return;\n  }\n  const guesses = serializeGuesses(gridData);\n  const saveData = {\n    date: Date.now(),\n    guesses\n  };\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\nexports.saveGuesses = saveGuesses;\nfunction serializeGuesses(gridData) {\n  const guesses = gridData.reduce((memo, row, r) => row.reduce((memoInner, cellData, c) => {\n    var _a;\n    const {\n      guess\n    } = cellData;\n    if (guess !== '') {\n      memoInner[\"\".concat(r, \"_\").concat(c)] = (_a = cellData.guess) !== null && _a !== void 0 ? _a : '';\n    }\n    return memoInner;\n  }, memo), {});\n  return guesses;\n}\nexports.serializeGuesses = serializeGuesses;\nfunction loadGuesses(gridData, storageKey) {\n  const {\n    localStorage\n  } = window;\n  if (!localStorage) {\n    return;\n  }\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n  const saveData = JSON.parse(saveRaw);\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\nexports.loadGuesses = loadGuesses;\nfunction deserializeGuesses(gridData, guesses) {\n  Object.entries(guesses).forEach(_ref3 => {\n    let [key, val] = _ref3;\n    const [rStr, cStr] = key.split('_');\n    const r = parseInt(rStr, 10);\n    const c = parseInt(cStr, 10);\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      gridData[r][c].guess = val;\n    }\n  });\n}\nexports.deserializeGuesses = deserializeGuesses;\nfunction findCorrectAnswers(data, gridData) {\n  const correctAnswers = [];\n  exports.bothDirections.forEach(direction => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(_ref4 => {\n      let [num, info] = _ref4;\n      const {\n        row,\n        col\n      } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if (gridData[r][c].guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n  return correctAnswers;\n}\nexports.findCorrectAnswers = findCorrectAnswers;","map":{"version":3,"names":["directionInfo","across","primary","orthogonal","down","exports","bothDirections","Object","keys","isAcross","direction","otherDirection","calculateExtents","data","dir","primaryMax","orthogonalMax","entries","forEach","_ref","info","answer","length","rowColMax","row","col","createEmptyGrid","rows","cols","gridData","Array","r","c","used","fillClues","clues","_ref2","number","rowStart","colStart","clue","i","cellData","push","sort","byNumber","createGridData","allowNonSquare","acrossMax","downMax","Math","max","size","a","b","aNum","Number","parseInt","bNum","clearGuesses","storageKey","window","localStorage","removeItem","saveGuesses","guesses","serializeGuesses","saveData","date","Date","now","setItem","JSON","stringify","reduce","memo","memoInner","guess","concat","_a","loadGuesses","saveRaw","getItem","parse","deserializeGuesses","_ref3","key","val","rStr","cStr","split","findCorrectAnswers","correctAnswers","_ref4","num","correct"],"sources":["C:\\Users\\Nabila\\Desktop\\aksara\\node_modules\\@jaredreisinger\\react-crossword\\src\\util.ts"],"sourcesContent":["import type {\n  AnswerTuple,\n  CellData,\n  CluesData,\n  CluesInput,\n  Direction,\n  GridData,\n  UsedCellData,\n} from './types';\n\ntype RowOrCol = 'row' | 'col';\n\nconst directionInfo: Record<\n  Direction,\n  { primary: RowOrCol; orthogonal: RowOrCol }\n> = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row',\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col',\n  },\n};\n\ninterface RowColMax {\n  row: number;\n  col: number;\n}\n\nexport const bothDirections = Object.keys(directionInfo) as Direction[];\n\nexport function isAcross(direction: Direction) {\n  return direction === 'across';\n}\n\nexport function otherDirection(direction: Direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\n\nexport function calculateExtents(data: CluesInput, direction: Direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n\n  Object.entries(data[direction]).forEach(([, info]) => {\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n\n  const rowColMax: RowColMax = {\n    row: 0,\n    col: 0,\n  };\n\n  rowColMax[dir.primary] = primaryMax;\n  rowColMax[dir.orthogonal] = orthogonalMax;\n\n  return rowColMax;\n}\n\n// const emptyCellData: Partial<CellData> = {\n//   used: false,\n//   // number: undefined, // null,\n//   // answer: '',\n//   // guess: '',\n//   // row: r,\n//   // col: c,\n//   // across: '', //null,\n//   // down: '', //null,\n// } as const;\n\nexport function createEmptyGrid(rows: number, cols: number) {\n  const gridData: GridData = Array(rows);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < rows; r++) {\n    gridData[r] = Array(cols);\n    for (let c = 0; c < cols; c++) {\n      gridData[r][c] = {\n        // ...emptyCellData,\n        row: r,\n        col: c,\n        used: false,\n      };\n    }\n  }\n\n  return gridData;\n}\n\nexport function fillClues(\n  gridData: GridData,\n  clues: CluesData,\n  data: CluesInput,\n  direction: Direction\n) {\n  const dir = directionInfo[direction];\n\n  Object.entries(data[direction]).forEach(([number, info]) => {\n    const { row: rowStart, col: colStart, clue, answer } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === 'row' ? i : 0);\n      const col = colStart + (dir.primary === 'col' ? i : 0);\n      const cellData = gridData[row][col] as UsedCellData;\n\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n\n    clues[direction].push({\n      number,\n      clue,\n      answer,\n      col: colStart,\n      row: rowStart,\n    });\n  });\n\n  clues[direction].sort(byNumber);\n}\n\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nexport function createGridData(data: CluesInput, allowNonSquare?: boolean) {\n  const acrossMax = calculateExtents(data, 'across');\n  const downMax = calculateExtents(data, 'down');\n\n  let rows = Math.max(acrossMax.row, downMax.row) + 1;\n  let cols = Math.max(acrossMax.col, downMax.col) + 1;\n\n  if (!allowNonSquare) {\n    const size = Math.max(rows, cols);\n    rows = size;\n    cols = size;\n  }\n\n  const gridData = createEmptyGrid(rows, cols);\n\n  // Now fill with answers... and also collect the clues\n  const clues: CluesData = {\n    across: [],\n    down: [],\n  };\n\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n\n  return { rows, cols, gridData, clues };\n}\n\n// sort helper for clues...\ninterface HasNumber {\n  number: string;\n}\n\nexport function byNumber(a: HasNumber, b: HasNumber) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n\n  return aNum - bNum;\n}\n\n// Guesses *really* only needs the \"guess\" property...\nexport type GuessData = ({ guess?: string } | CellData)[][];\n\nexport function clearGuesses(storageKey: string) {\n  if (!window.localStorage) {\n    return;\n  }\n\n  window.localStorage.removeItem(storageKey);\n}\n\nexport function saveGuesses(gridData: GuessData, storageKey: string) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const guesses = serializeGuesses(gridData);\n\n  const saveData = {\n    date: Date.now(),\n    guesses,\n  };\n\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\n\nexport function serializeGuesses(gridData: GuessData) {\n  const guesses = gridData.reduce<Record<string, string>>(\n    (memo, row, r) =>\n      row.reduce<Record<string, string>>((memoInner, cellData, c) => {\n        const { guess } = cellData as UsedCellData;\n        if (guess !== '') {\n          memoInner[`${r}_${c}`] = (cellData as UsedCellData).guess ?? '';\n        }\n        return memoInner;\n      }, memo),\n    {}\n  );\n\n  return guesses;\n}\n\nexport function loadGuesses(gridData: GuessData, storageKey: string) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n\n  const saveData = JSON.parse(saveRaw);\n\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\n\nexport function deserializeGuesses(\n  gridData: GuessData,\n  guesses: Record<string, string>\n) {\n  Object.entries(guesses).forEach(([key, val]) => {\n    const [rStr, cStr] = key.split('_');\n    const r = parseInt(rStr, 10);\n    const c = parseInt(cStr, 10);\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      (gridData[r][c] as UsedCellData).guess = val;\n    }\n  });\n}\n\nexport function findCorrectAnswers(data: CluesInput, gridData: GuessData) {\n  const correctAnswers: AnswerTuple[] = [];\n\n  bothDirections.forEach((direction) => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(([num, info]) => {\n      const { row, col } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if ((gridData[r][c] as UsedCellData).guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n\n  return correctAnswers;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}