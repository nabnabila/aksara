{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = require(\"react\");\nconst prop_types_1 = __importDefault(require(\"prop-types\"));\nconst styled_components_1 = __importStar(require(\"styled-components\"));\nconst Cell_1 = __importDefault(require(\"./Cell\"));\nconst context_1 = require(\"./context\");\n// import {\n// } from './types';\nconst defaultTheme = {\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)'\n};\nconst GridWrapper = styled_components_1.default.div.attrs(( /* props */\n) => ({\n  className: 'crossword grid'\n}))`\n  /* position: relative; */\n  /* min-width: 20rem; */\n  /* max-width: 60rem; Should the size matter? */\n  width: auto;\n  flex: 2 1 50%;\n`;\nconst CrosswordGridPropTypes = {\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: prop_types_1.default.shape({\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: prop_types_1.default.string,\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: prop_types_1.default.string,\n    /**  background for an answer cell */\n    cellBackground: prop_types_1.default.string,\n    /** border for an answer cell */\n    cellBorder: prop_types_1.default.string,\n    /** color for answer text (entered by the player) */\n    textColor: prop_types_1.default.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: prop_types_1.default.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: prop_types_1.default.string,\n    /** background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue  */\n    highlightBackground: prop_types_1.default.string\n  })\n};\n// export interface CrosswordGridImperative {\n//   /**\n//    * Sets focus to the crossword component.\n//    */\n//   focus: () => void;\n// }\n/**\n * The rendering component for the crossword grid itself.\n */\nfunction CrosswordGrid({\n  theme\n}) {\n  const {\n    rows,\n    cols,\n    gridData,\n    handleInputKeyDown,\n    handleInputChange,\n    handleCellClick,\n    handleInputClick,\n    registerFocusHandler,\n    focused,\n    selectedPosition: {\n      row: focusedRow,\n      col: focusedCol\n    },\n    selectedDirection: currentDirection,\n    selectedNumber: currentNumber\n  } = (0, react_1.useContext)(context_1.CrosswordContext);\n  const inputRef = (0, react_1.useRef)(null);\n  const contextTheme = (0, react_1.useContext)(styled_components_1.ThemeContext);\n  // focus and movement\n  const focus = (0, react_1.useCallback)(() => {\n    var _a;\n    // console.log('CrosswordGrid.focus()', { haveRef: !!inputRef.current });\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n  }, []);\n  (0, react_1.useEffect)(() => {\n    // focus.name = 'CrosswordGrid.focus()';\n    registerFocusHandler(focus);\n    return () => {\n      registerFocusHandler(null);\n    };\n  }, [focus, registerFocusHandler]);\n  // We have several properties that we bundle together as context for the\n  // cells, rather than have them as independent properties.  (Or should they\n  // stay separate? Or be passed as \"spread\" values?)\n  //\n  // We used to calculate sizes as \"fractions of 100\", meaning that the more\n  // rows or columns, the smaller the values would get.  In order to support\n  // non-square crossword grids, it makes much more sense to use a \"fixed\" cell\n  // size, and then calculate the overall extents as a multiple of the cell\n  // size.\n  const cellSize = 10;\n  const cellPadding = 0.125;\n  const cellInner = cellSize - cellPadding * 2;\n  const cellHalf = cellSize / 2;\n  const fontSize = cellInner * 0.7;\n  const sizeContext = (0, react_1.useMemo)(() => ({\n    cellSize,\n    cellPadding,\n    cellInner,\n    cellHalf,\n    fontSize\n  }), [cellSize, cellPadding, cellInner, cellHalf, fontSize]);\n  const height = (0, react_1.useMemo)(() => rows * cellSize, [rows]);\n  const width = (0, react_1.useMemo)(() => cols * cellSize, [cols]);\n  const cellWidthHtmlPct = (0, react_1.useMemo)(() => 100 / cols, [cols]);\n  const cellHeightHtmlPct = (0, react_1.useMemo)(() => 100 / rows, [rows]);\n  // In order to ensure the top/left positioning makes sense, there is an\n  // absolutely-positioned <div> with no margin/padding that we *don't* expose\n  // to consumers.  This keeps the math much more reliable.  (But we're still\n  // seeing a slight vertical deviation towards the bottom of the grid!  The \"*\n  // 0.995\" seems to help.)  We also need to calculate the effective px size of\n  // the automatically-scaled SVG cells.  We know that \"100% width\" === \"number\n  // of columns\".\n  const inputStyle = (0, react_1.useMemo)(() => ({\n    position: 'absolute',\n    top: `calc(${focusedRow * cellHeightHtmlPct * 0.995}% + 2px)`,\n    left: `calc(${focusedCol * cellWidthHtmlPct}% + 2px)`,\n    width: `calc(${cellWidthHtmlPct}% - 4px)`,\n    height: `calc(${cellHeightHtmlPct}% - 4px)`,\n    fontSize: `${fontSize * 6}px`,\n    textAlign: 'center',\n    textAnchor: 'middle',\n    backgroundColor: 'transparent',\n    caretColor: 'transparent',\n    margin: 0,\n    padding: 0,\n    border: 0,\n    cursor: 'default'\n  }), [cellWidthHtmlPct, cellHeightHtmlPct, focusedRow, focusedCol, fontSize]);\n  // The final theme is the merger of three values: the \"theme\" property\n  // passed to the component (which takes precedence), any values from\n  // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n  // needed ones that are missing.  (We create this in standard last-one-wins\n  // order in Javascript, of course.)\n  const finalTheme = (0, react_1.useMemo)(() => Object.assign(Object.assign(Object.assign({}, defaultTheme), contextTheme), theme), [contextTheme, theme]);\n  return (0, jsx_runtime_1.jsx)(context_1.CrosswordSizeContext.Provider, Object.assign({\n    value: sizeContext\n  }, {\n    children: (0, jsx_runtime_1.jsx)(styled_components_1.ThemeProvider, Object.assign({\n      theme: finalTheme\n    }, {\n      children: (0, jsx_runtime_1.jsx)(GridWrapper, {\n        children: (0, jsx_runtime_1.jsxs)(\"div\", Object.assign({\n          style: {\n            margin: 0,\n            padding: 0,\n            position: 'relative'\n          }\n        }, {\n          children: [(0, jsx_runtime_1.jsxs)(\"svg\", Object.assign({\n            viewBox: `0 0 ${width} ${height}`\n          }, {\n            children: [(0, jsx_runtime_1.jsx)(\"rect\", {\n              x: 0,\n              y: 0,\n              width: width,\n              height: height,\n              fill: finalTheme.gridBackground\n            }), gridData.flatMap((rowData, row) => rowData.map((cellData, col) => cellData.used ?\n            // Should the Cell figure out its focus/highlight state\n            // directly from the CrosswordContext?\n            (0, jsx_runtime_1.jsx)(Cell_1.default\n            // eslint-disable-next-line react/no-array-index-key\n            , {\n              cellData: cellData,\n              focus: focused && row === focusedRow && col === focusedCol,\n              highlight: focused && !!currentNumber && cellData[currentDirection] === currentNumber,\n              onClick: handleCellClick\n            }, `R${row}C${col}`) : undefined))]\n          })), (0, jsx_runtime_1.jsx)(\"input\", {\n            ref: inputRef,\n            \"aria-label\": \"crossword-input\",\n            type: \"text\",\n            onClick: handleInputClick,\n            onKeyDown: handleInputKeyDown,\n            onChange: handleInputChange,\n            value: \"\",\n            // onInput={this.handleInput}\n            autoComplete: \"off\",\n            spellCheck: \"false\",\n            autoCorrect: \"off\",\n            style: inputStyle\n          })]\n        }))\n      })\n    }))\n  }));\n}\nexports.default = CrosswordGrid;\nCrosswordGrid.propTypes = CrosswordGridPropTypes;\nCrosswordGrid.defaultProps = {\n  theme: null\n};","map":{"version":3,"names":["react_1","require","prop_types_1","__importDefault","styled_components_1","__importStar","Cell_1","context_1","defaultTheme","columnBreakpoint","gridBackground","cellBackground","cellBorder","textColor","numberColor","focusBackground","highlightBackground","GridWrapper","default","div","attrs","className","CrosswordGridPropTypes","theme","shape","string","CrosswordGrid","rows","cols","gridData","handleInputKeyDown","handleInputChange","handleCellClick","handleInputClick","registerFocusHandler","focused","selectedPosition","row","focusedRow","col","focusedCol","selectedDirection","currentDirection","selectedNumber","currentNumber","useContext","CrosswordContext","inputRef","useRef","contextTheme","ThemeContext","focus","useCallback","_a","current","useEffect","cellSize","cellPadding","cellInner","cellHalf","fontSize","sizeContext","useMemo","height","width","cellWidthHtmlPct","cellHeightHtmlPct","inputStyle","position","top","left","textAlign","textAnchor","backgroundColor","caretColor","margin","padding","border","cursor","finalTheme","Object","assign","jsx_runtime_1","jsx","CrosswordSizeContext","Provider","value","children","ThemeProvider","jsxs","style","viewBox","x","y","fill","flatMap","rowData","map","cellData","used","highlight","onClick","undefined","ref","type","onKeyDown","onChange","autoComplete","spellCheck","autoCorrect","exports","propTypes","defaultProps"],"sources":["C:\\Users\\Nabila\\Desktop\\aksara\\node_modules\\@jaredreisinger\\react-crossword\\src\\CrosswordGrid.tsx"],"sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  // useImperativeHandle,\n  useMemo,\n  useRef,\n} from 'react';\nimport PropTypes, { InferProps } from 'prop-types';\n\nimport styled, { ThemeContext, ThemeProvider } from 'styled-components';\n\nimport Cell from './Cell';\n\nimport { CrosswordContext, CrosswordSizeContext } from './context';\nimport { FocusHandler } from './types';\n\n// import {\n// } from './types';\n\nconst defaultTheme = {\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)',\n};\n\nconst GridWrapper = styled.div.attrs((/* props */) => ({\n  className: 'crossword grid',\n}))`\n  /* position: relative; */\n  /* min-width: 20rem; */\n  /* max-width: 60rem; Should the size matter? */\n  width: auto;\n  flex: 2 1 50%;\n`;\n\nconst CrosswordGridPropTypes = {\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: PropTypes.shape({\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: PropTypes.string,\n\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: PropTypes.string,\n    /**  background for an answer cell */\n    cellBackground: PropTypes.string,\n    /** border for an answer cell */\n    cellBorder: PropTypes.string,\n    /** color for answer text (entered by the player) */\n    textColor: PropTypes.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: PropTypes.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: PropTypes.string,\n    /** background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue  */\n    highlightBackground: PropTypes.string,\n  }),\n};\n\nexport type CrosswordGridProps = InferProps<typeof CrosswordGridPropTypes>;\n\n// export interface CrosswordGridImperative {\n//   /**\n//    * Sets focus to the crossword component.\n//    */\n//   focus: () => void;\n// }\n\n/**\n * The rendering component for the crossword grid itself.\n */\nexport default function CrosswordGrid({ theme }: CrosswordGridProps) {\n  const {\n    rows,\n    cols,\n    gridData,\n    handleInputKeyDown,\n    handleInputChange,\n    handleCellClick,\n    handleInputClick,\n    registerFocusHandler,\n    focused,\n    selectedPosition: { row: focusedRow, col: focusedCol },\n    selectedDirection: currentDirection,\n    selectedNumber: currentNumber,\n  } = useContext(CrosswordContext);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const contextTheme = useContext(ThemeContext);\n\n  // focus and movement\n  const focus = useCallback<FocusHandler>(() => {\n    // console.log('CrosswordGrid.focus()', { haveRef: !!inputRef.current });\n    inputRef.current?.focus();\n  }, []);\n\n  useEffect(() => {\n    // focus.name = 'CrosswordGrid.focus()';\n    registerFocusHandler(focus);\n\n    return () => {\n      registerFocusHandler(null);\n    };\n  }, [focus, registerFocusHandler]);\n\n  // We have several properties that we bundle together as context for the\n  // cells, rather than have them as independent properties.  (Or should they\n  // stay separate? Or be passed as \"spread\" values?)\n  //\n  // We used to calculate sizes as \"fractions of 100\", meaning that the more\n  // rows or columns, the smaller the values would get.  In order to support\n  // non-square crossword grids, it makes much more sense to use a \"fixed\" cell\n  // size, and then calculate the overall extents as a multiple of the cell\n  // size.\n  const cellSize = 10;\n  const cellPadding = 0.125;\n  const cellInner = cellSize - cellPadding * 2;\n  const cellHalf = cellSize / 2;\n  const fontSize = cellInner * 0.7;\n\n  const sizeContext = useMemo(\n    () => ({\n      cellSize,\n      cellPadding,\n      cellInner,\n      cellHalf,\n      fontSize,\n    }),\n    [cellSize, cellPadding, cellInner, cellHalf, fontSize]\n  );\n\n  const height = useMemo(() => rows * cellSize, [rows]);\n  const width = useMemo(() => cols * cellSize, [cols]);\n  const cellWidthHtmlPct = useMemo(() => 100 / cols, [cols]);\n  const cellHeightHtmlPct = useMemo(() => 100 / rows, [rows]);\n\n  // In order to ensure the top/left positioning makes sense, there is an\n  // absolutely-positioned <div> with no margin/padding that we *don't* expose\n  // to consumers.  This keeps the math much more reliable.  (But we're still\n  // seeing a slight vertical deviation towards the bottom of the grid!  The \"*\n  // 0.995\" seems to help.)  We also need to calculate the effective px size of\n  // the automatically-scaled SVG cells.  We know that \"100% width\" === \"number\n  // of columns\".\n  const inputStyle = useMemo(\n    () =>\n      ({\n        position: 'absolute',\n        top: `calc(${focusedRow * cellHeightHtmlPct * 0.995}% + 2px)`,\n        left: `calc(${focusedCol * cellWidthHtmlPct}% + 2px)`,\n        width: `calc(${cellWidthHtmlPct}% - 4px)`,\n        height: `calc(${cellHeightHtmlPct}% - 4px)`,\n        fontSize: `${fontSize * 6}px`, // waaay too small...?\n        textAlign: 'center',\n        textAnchor: 'middle',\n        backgroundColor: 'transparent',\n        caretColor: 'transparent',\n        margin: 0,\n        padding: 0,\n        border: 0,\n        cursor: 'default',\n      } as const),\n    [cellWidthHtmlPct, cellHeightHtmlPct, focusedRow, focusedCol, fontSize]\n  );\n\n  // The final theme is the merger of three values: the \"theme\" property\n  // passed to the component (which takes precedence), any values from\n  // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n  // needed ones that are missing.  (We create this in standard last-one-wins\n  // order in Javascript, of course.)\n  const finalTheme = useMemo(\n    () => ({ ...defaultTheme, ...contextTheme, ...theme }),\n    [contextTheme, theme]\n  );\n\n  return (\n    <CrosswordSizeContext.Provider value={sizeContext}>\n      <ThemeProvider theme={finalTheme}>\n        <GridWrapper>\n          {/*\n            This div is hard-coded because we *need* a zero-padded,relative-\n            positioned element for aligning the <input> with the cells in the\n            <svg>.\n          */}\n          <div style={{ margin: 0, padding: 0, position: 'relative' }}>\n            <svg viewBox={`0 0 ${width} ${height}`}>\n              <rect\n                x={0}\n                y={0}\n                width={width}\n                height={height}\n                fill={finalTheme.gridBackground}\n              />\n              {gridData.flatMap((rowData, row) =>\n                rowData.map((cellData, col) =>\n                  cellData.used ? (\n                    // Should the Cell figure out its focus/highlight state\n                    // directly from the CrosswordContext?\n                    <Cell\n                      // eslint-disable-next-line react/no-array-index-key\n                      key={`R${row}C${col}`}\n                      cellData={cellData}\n                      focus={\n                        focused && row === focusedRow && col === focusedCol\n                      }\n                      highlight={\n                        focused &&\n                        !!currentNumber &&\n                        cellData[currentDirection] === currentNumber\n                      }\n                      onClick={handleCellClick}\n                    />\n                  ) : undefined\n                )\n              )}\n            </svg>\n            <input\n              ref={inputRef}\n              aria-label=\"crossword-input\"\n              type=\"text\"\n              onClick={handleInputClick}\n              onKeyDown={handleInputKeyDown}\n              onChange={handleInputChange}\n              value=\"\"\n              // onInput={this.handleInput}\n              autoComplete=\"off\"\n              spellCheck=\"false\"\n              autoCorrect=\"off\"\n              style={inputStyle}\n            />\n          </div>\n        </GridWrapper>\n      </ThemeProvider>\n    </CrosswordSizeContext.Provider>\n  );\n}\n\nCrosswordGrid.propTypes = CrosswordGridPropTypes;\n\nCrosswordGrid.defaultProps = {\n  theme: null,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}