{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.crosswordProviderPropTypes = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\n/* eslint-disable no-console */\nconst react_1 = __importStar(require(\"react\"));\nconst prop_types_1 = __importDefault(require(\"prop-types\"));\nconst immer_1 = __importDefault(require(\"immer\"));\nconst styled_components_1 = require(\"styled-components\");\nconst context_1 = require(\"./context\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\nconst defaultStorageKey = 'guesses';\nexports.crosswordProviderPropTypes = {\n  /**\n   * clue/answer data; see <a\n   * href=\"#/Configuration%20and%20customization/Clue%20input%20format\">Clue\n   * input format</a> for details.\n   */\n  data: types_1.cluesInputShapeOriginal.isRequired,\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: prop_types_1.default.shape({\n    /**\n     * whether to allow a non-square rendering\n     * @since 5.1.0\n     */\n    allowNonSquare: prop_types_1.default.bool,\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: prop_types_1.default.string,\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: prop_types_1.default.string,\n    /**  background for an answer cell */\n    cellBackground: prop_types_1.default.string,\n    /** border for an answer cell */\n    cellBorder: prop_types_1.default.string,\n    /** color for answer text (entered by the player) */\n    textColor: prop_types_1.default.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: prop_types_1.default.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: prop_types_1.default.string,\n    /**\n     * background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue\n     */\n    highlightBackground: prop_types_1.default.string\n  }),\n  /** whether to use browser storage to persist the player's work-in-progress */\n  useStorage: prop_types_1.default.bool,\n  /**\n   * a custom storage key to use for persistence; defaults to \"guesses\" when not\n   * provided\n   */\n  storageKey: prop_types_1.default.string,\n  /**\n   * callback function that fires when a player completes an answer, whether\n   * correct or not; called with `(direction, number, correct, answer)`\n   * arguments, where `direction` is `'across'` or `'down'`, `number` is the\n   * clue number as text (like `'1'`), `correct` is whether the guessed answer\n   * is correct and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerComplete: prop_types_1.default.func,\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)\n   */\n  onAnswerCorrect: prop_types_1.default.func,\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @deprecated 4.3.0; being replaced by `onAnswerCorrect` (to reduce\n   * ambiguity)\n   */\n  onCorrect: prop_types_1.default.func,\n  /**\n   * callback function that fires when a player answers a clue *in*correctly;\n   * called with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerIncorrect: prop_types_1.default.func,\n  /**\n   * callback function that's called when a crossword is loaded, to batch up\n   * correct answers loaded from storage; passed an array of the same values\n   * that `onCorrect` would recieve\n   */\n  onLoadedCorrect: prop_types_1.default.func,\n  /**\n   * callback function that's called when the overall crossword is complete,\n   * whether correct or not; called with `(correct)` argument, a boolean which\n   * indicates whether the crossword is correct or not.\n   */\n  onCrosswordComplete: prop_types_1.default.func,\n  /**\n   * callback function that's called when the overall crossword is completely\n   * correct (or not)\n   *\n   * NOTE: this will be deprecated for `onCrosswordComplete` in the future.\n   */\n  onCrosswordCorrect: prop_types_1.default.func,\n  /**\n   * callback function called when a cell changes (e.g. when the user types a\n   * letter); called with `(row, col, char)` arguments, where the `row` and\n   * `column` are the 0-based position of the cell, and `char` is the character\n   * typed (already massaged into upper-case)\n   */\n  onCellChange: prop_types_1.default.func,\n  /**\n   * callback function called when a clue is selected\n   */\n  onClueSelected: prop_types_1.default.func,\n  children: prop_types_1.default.node\n};\nconst defaultTheme = {\n  allowNonSquare: false,\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)'\n};\n/**\n * The fundamental logic and data management component for react-crossword.\n * Prior to 4.0, puzzle management was built into the `Crossword` component.  As\n * of 4.0, the logic implementation has been refactored such that `Crossword`\n * leverages `CrosswordProvider` to do the heavy lifting.\n *\n * @since 4.0\n */\nconst CrosswordProvider = react_1.default.forwardRef((_ref, ref) => {\n  let {\n    data,\n    theme,\n    onAnswerComplete,\n    onAnswerCorrect,\n    onCorrect,\n    onAnswerIncorrect,\n    onLoadedCorrect,\n    onCrosswordComplete,\n    onCrosswordCorrect,\n    onCellChange,\n    onClueSelected,\n    useStorage,\n    storageKey,\n    children\n  } = _ref;\n  const contextTheme = (0, react_1.useContext)(styled_components_1.ThemeContext);\n  // The final theme is the merger of three values: the \"theme\" property\n  // passed to the component (which takes precedence), any values from\n  // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n  // needed ones that are missing.  (We create this in standard last-one-wins\n  // order in Javascript, of course.)\n  const finalTheme = (0, react_1.useMemo)(() => Object.assign(Object.assign(Object.assign({}, defaultTheme), contextTheme), theme), [contextTheme, theme]);\n  // The original Crossword implementation used separate state to track size\n  // and grid data, and conflated the clues-input-data-based grid data and the\n  // player input guesses.  Let's see if we can keep the clues-input and\n  // player data segregated.\n  const {\n    rows,\n    cols,\n    gridData: masterGridData,\n    clues: masterClues\n  } = (0, react_1.useMemo)(() => {\n    var _a;\n    return (0, util_1.createGridData)(data, (_a = finalTheme.allowNonSquare) !== null && _a !== void 0 ? _a : false);\n  }, [data, finalTheme.allowNonSquare]);\n  const [gridData, setGridData] = (0, react_1.useState)([]);\n  const [clues, setClues] = (0, react_1.useState)();\n  // We can't seem to use state to track the registeredFocusHandler, because\n  // there seems to be a delay in 'focus' being usable after it's set.  We use\n  // a Ref instead.\n  const registeredFocusHandler = (0, react_1.useRef)(null);\n  // interactive player state\n  const [focused, setFocused] = (0, react_1.useState)(false);\n  const [focusedRow, setFocusedRow] = (0, react_1.useState)(0); // rename to selectedRow?\n  const [focusedCol, setFocusedCol] = (0, react_1.useState)(0);\n  const [currentDirection, setCurrentDirection] = (0, react_1.useState)('across');\n  const [currentNumber, setCurrentNumber] = (0, react_1.useState)('1');\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [bulkChange, setBulkChange] = (0, react_1.useState)(null);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [checkQueue, setCheckQueue] = (0, react_1.useState)([]);\n  // This *internal* getCellData assumes that it's only ever asked for a valid\n  // cell (one that's used).\n  const getCellData = (0, react_1.useCallback)((row, col) => {\n    if (row >= 0 && row < rows && col >= 0 && col < cols) {\n      return gridData[row][col];\n    }\n    // fake cellData to represent \"out of bounds\"\n    return {\n      row,\n      col,\n      used: false,\n      outOfBounds: true\n    };\n  }, [cols, gridData, rows]);\n  const setCellCharacter = (0, react_1.useCallback)((row, col, char) => {\n    const cell = getCellData(row, col);\n    if (!cell.used) {\n      throw new Error('unexpected setCellCharacter call');\n    }\n    // If the character is already the cell's guess, there's nothing to do.\n    if (cell.guess === char) {\n      return;\n    }\n    // update the gridData with the guess\n    setGridData((0, immer_1.default)(draft => {\n      draft[row][col].guess = char;\n    }));\n    // push the row/col for checking!\n    setCheckQueue((0, immer_1.default)(draft => {\n      draft.push({\n        row,\n        col\n      });\n    }));\n    if (onCellChange) {\n      onCellChange(row, col, char);\n    }\n  }, [getCellData, onCellChange]);\n  const notifyAnswerComplete = (0, react_1.useCallback)((direction, number, correct, answer) => {\n    if (onAnswerComplete) {\n      onAnswerComplete(direction, number, correct, answer);\n    }\n    if (correct) {\n      if (onAnswerCorrect) {\n        onAnswerCorrect(direction, number, answer);\n      }\n      // NOTE: onCorrect to be (eventually) deprecated\n      if (onCorrect) {\n        onCorrect(direction, number, answer);\n      }\n    } else if (onAnswerIncorrect) {\n      onAnswerIncorrect(direction, number, answer);\n    }\n  }, [onAnswerComplete, onAnswerCorrect, onAnswerIncorrect, onCorrect]);\n  const checkCorrectness = (0, react_1.useCallback)((row, col) => {\n    const cell = getCellData(row, col);\n    if (!cell.used) {\n      // Because this is in an internal callback, and we only call it with a\n      // valid cell (row/col), the throw line isn't testable... so we ignore\n      // it.\n      /* istanbul ignore next */\n      throw new Error('unexpected unused cell');\n    }\n    // check all the cells for both across and down answers that use this\n    // cell\n    util_1.bothDirections.forEach(direction => {\n      const across = (0, util_1.isAcross)(direction);\n      const number = cell[direction];\n      if (!number) {\n        return;\n      }\n      const info = data[direction][number];\n      // We send correct/incorrect messages, but *only* if every cell in the\n      // answer is filled out; there's no point in reporting \"incorrect\"\n      // when the answer is simply incomplete.\n      let complete = true;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const checkCell = getCellData(info.row + (across ? 0 : i), info.col + (across ? i : 0));\n        if (!checkCell.guess) {\n          complete = false;\n          correct = false;\n          break;\n        }\n        if (checkCell.guess !== checkCell.answer) {\n          correct = false;\n        }\n      }\n      // update the clue state\n      setClues((0, immer_1.default)(draft => {\n        if (draft) {\n          const clueInfo = draft[direction].find(i => i.number === number);\n          if (clueInfo) {\n            clueInfo.complete = complete;\n            clueInfo.correct = correct;\n          }\n        }\n      }));\n      if (complete) {\n        notifyAnswerComplete(direction, number, correct, info.answer);\n      }\n    });\n  }, [data, getCellData, notifyAnswerComplete]);\n  // Any time the checkQueue changes, call checkCorrectness!\n  (0, react_1.useEffect)(() => {\n    if (checkQueue.length === 0) {\n      return;\n    }\n    checkQueue.forEach(_ref2 => {\n      let {\n        row,\n        col\n      } = _ref2;\n      return checkCorrectness(row, col);\n    });\n    setCheckQueue([]);\n  }, [checkQueue, checkCorrectness]);\n  // Any time the clues change, determine if they are all complete/correct or\n  // not.\n  const {\n    crosswordComplete,\n    crosswordCorrect\n  } = (0, react_1.useMemo)(() => {\n    const complete = !!(clues && util_1.bothDirections.every(direction => clues[direction].every(clueInfo => clueInfo.complete)));\n    const correct = complete && !!(clues && util_1.bothDirections.every(direction => clues[direction].every(clueInfo => clueInfo.correct)));\n    // console.log('setting crossword correct', { clues, correct });\n    return {\n      crosswordComplete: complete,\n      crosswordCorrect: correct\n    };\n  }, [clues]);\n  // Let the consumer know everything's correct (or not) if they've asked to\n  // be informed.\n  (0, react_1.useEffect)(() => {\n    if (crosswordComplete) {\n      if (onCrosswordComplete) {\n        onCrosswordComplete(crosswordCorrect);\n      }\n      if (onCrosswordCorrect) {\n        onCrosswordCorrect(crosswordCorrect);\n      }\n    }\n  }, [crosswordComplete, crosswordCorrect, onCrosswordComplete, onCrosswordCorrect]);\n  // focus and movement\n  const focus = (0, react_1.useCallback)(() => {\n    // console.log('CrosswordProvider.focus() called...');\n    // If there's a registered focus handler, use it!\n    if (registeredFocusHandler.current) {\n      // console.log('calling registered focus handler...');\n      registeredFocusHandler.current();\n      setFocused(true);\n    } else {\n      console.warn('CrosswordProvider: focus() has no registered handler to call!');\n    }\n  }, []);\n  const moveTo = (0, react_1.useCallback)((row, col, directionOverride) => {\n    var _a;\n    let direction = directionOverride !== null && directionOverride !== void 0 ? directionOverride : currentDirection;\n    const candidate = getCellData(row, col);\n    if (!candidate.used) {\n      return false;\n    }\n    // If we try to move to a cell with a direction it doesn't support,\n    // switch to the other direction.  There is no codepath that can test\n    // this, though, as this callback isn't exposed, and we only call it in\n    // ways that guarantee that direction is valid.\n    if (!candidate[direction]) {\n      /* istanbul ignore next */\n      direction = (0, util_1.otherDirection)(direction);\n    }\n    setFocusedRow(row);\n    setFocusedCol(col);\n    setCurrentDirection(direction);\n    setCurrentNumber((_a = candidate[direction]) !== null && _a !== void 0 ? _a : '');\n    return candidate;\n  }, [currentDirection, getCellData]);\n  const moveRelative = (0, react_1.useCallback)((dRow, dCol) => {\n    // We expect *only* one of dRow or dCol to have a non-zero value, and\n    // that's the direction we will \"prefer\".  If *both* are set (or zero),\n    // we don't change the direction.\n    let direction;\n    if (dRow !== 0 && dCol === 0) {\n      direction = 'down';\n    } else if (dRow === 0 && dCol !== 0) {\n      direction = 'across';\n    }\n    const cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);\n    return cell;\n  }, [focusedRow, focusedCol, moveTo]);\n  const moveForward = (0, react_1.useCallback)(() => {\n    const across = (0, util_1.isAcross)(currentDirection);\n    moveRelative(across ? 0 : 1, across ? 1 : 0);\n  }, [currentDirection, moveRelative]);\n  const moveBackward = (0, react_1.useCallback)(() => {\n    const across = (0, util_1.isAcross)(currentDirection);\n    moveRelative(across ? 0 : -1, across ? -1 : 0);\n  }, [currentDirection, moveRelative]);\n  // keyboard handling\n  const handleSingleCharacter = (0, react_1.useCallback)(char => {\n    setCellCharacter(focusedRow, focusedCol, char.toUpperCase());\n    moveForward();\n  }, [focusedRow, focusedCol, setCellCharacter, moveForward]);\n  // We use the keydown event for control/arrow keys, but not for textual\n  // input, because it's hard to suss out when a key is \"regular\" or not.\n  const handleInputKeyDown = (0, react_1.useCallback)(event => {\n    var _a;\n    // if ctrl, alt, or meta are down, ignore the event (let it bubble)\n    if (event.ctrlKey || event.altKey || event.metaKey) {\n      return;\n    }\n    let preventDefault = true;\n    const {\n      key\n    } = event;\n    // console.log('CROSSWORD KEYDOWN', event.key);\n    // FUTURE: should we \"jump\" over black space?  That might help some for\n    // keyboard users.\n    switch (key) {\n      case 'ArrowUp':\n        moveRelative(-1, 0);\n        break;\n      case 'ArrowDown':\n        moveRelative(1, 0);\n        break;\n      case 'ArrowLeft':\n        moveRelative(0, -1);\n        break;\n      case 'ArrowRight':\n        moveRelative(0, 1);\n        break;\n      case ' ': // treat space like tab?\n      case 'Tab':\n        {\n          const other = (0, util_1.otherDirection)(currentDirection);\n          const cellData = getCellData(focusedRow, focusedCol);\n          if (cellData[other]) {\n            setCurrentDirection(other);\n            setCurrentNumber((_a = cellData[other]) !== null && _a !== void 0 ? _a : '');\n          }\n          break;\n        }\n      // Backspace: delete the current cell, and move to the previous cell\n      // Delete:    delete the current cell, but don't move\n      case 'Backspace':\n      case 'Delete':\n        {\n          setCellCharacter(focusedRow, focusedCol, '');\n          if (key === 'Backspace') {\n            moveBackward();\n          }\n          break;\n        }\n      case 'Home':\n      case 'End':\n        {\n          // move to beginning/end of this entry?\n          const info = data[currentDirection][currentNumber];\n          const {\n            answer: {\n              length\n            }\n          } = info;\n          let {\n            row,\n            col\n          } = info;\n          if (key === 'End') {\n            const across = (0, util_1.isAcross)(currentDirection);\n            if (across) {\n              col += length - 1;\n            } else {\n              row += length - 1;\n            }\n          }\n          moveTo(row, col);\n          break;\n        }\n      default:\n        // It would be nice to handle \"regular\" characters with onInput, but\n        // that is still experimental, so we can't count on it.  Instead, we\n        // assume that only \"length 1\" values are regular.\n        if (key.length !== 1) {\n          preventDefault = false;\n          break;\n        }\n        handleSingleCharacter(key);\n        break;\n    }\n    if (preventDefault) {\n      event.preventDefault();\n    }\n  }, [moveRelative, handleSingleCharacter, currentDirection, getCellData, focusedRow, focusedCol, setCellCharacter, moveBackward, data, currentNumber, moveTo]);\n  const handleInputChange = (0, react_1.useCallback)(event => {\n    event.preventDefault();\n    setBulkChange(event.target.value);\n  }, []);\n  (0, react_1.useEffect)(() => {\n    if (!bulkChange) {\n      return;\n    }\n    // handle bulkChange by updating a character at a time (this lets us\n    // leverage the existing character-entry logic).\n    handleSingleCharacter(bulkChange[0]);\n    setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));\n  }, [bulkChange, handleSingleCharacter]);\n  // When the clues *input* data changes, reset/reload the player data\n  (0, react_1.useEffect)(() => {\n    // deep-clone the grid data...\n    const newGridData = masterGridData.map(row => row.map(cell => Object.assign({}, cell)));\n    // deep-clone the clue data...\n    const newCluesData = {\n      across: masterClues.across.map(clue => Object.assign({}, clue)),\n      down: masterClues.down.map(clue => Object.assign({}, clue))\n    };\n    if (useStorage) {\n      (0, util_1.loadGuesses)(newGridData, storageKey || defaultStorageKey);\n    }\n    setClues(newCluesData);\n    setGridData(newGridData);\n    // Check all of the clues to see if any were correct... but only if we\n    // loaded guesses.  Since the current implementation relies on state, we\n    // leverage the checkQueue to run through all the clues/guesses.\n    //\n    // Really, the ideal thing to do would be to write the checking-logic in a\n    // way that it doesn't assume the data is already in state... that would\n    // allow us to check everything directly, and simply set the same state\n    // that checkCorrectness() does, *and* properly call onLoadedCorrect(). As\n    // it is, this implementation can cause some answers to mentioned in\n    // onCorrect() more than once (any time an across answer starts inside a\n    // down answer, or vice versa.)\n    if (useStorage) {\n      setCheckQueue(util_1.bothDirections.flatMap(dir =>\n      // simply use the row/col that starts each answer.\n      newCluesData[dir].map(_ref3 => {\n        let {\n          row,\n          col\n        } = _ref3;\n        return {\n          row,\n          col\n        };\n      })));\n    }\n    // Should we start with 1-across highlighted/focused?\n    // TODO: track input-field focus so we don't draw highlight when we're not\n    // really focused, *and* use first actual clue (whether across or down?)\n    setFocusedRow(0);\n    setFocusedCol(0);\n    setCurrentDirection('across');\n    setCurrentNumber('1');\n  }, [masterClues, masterGridData, storageKey, useStorage]);\n  // save the guesses any time they change...\n  (0, react_1.useEffect)(() => {\n    if (gridData === null || !useStorage) {\n      return;\n    }\n    (0, util_1.saveGuesses)(gridData, storageKey || defaultStorageKey);\n  }, [gridData, storageKey, useStorage]);\n  const handleCellClick = (0, react_1.useCallback)(cellData => {\n    var _a;\n    if (cellData.used) {\n      const {\n        row,\n        col\n      } = cellData;\n      const other = (0, util_1.otherDirection)(currentDirection);\n      // should this use moveTo?\n      setFocusedRow(row);\n      setFocusedCol(col);\n      let direction = currentDirection;\n      // We switch to the \"other\" direction if (a) the current direction\n      // isn't available in the clicked cell, or (b) we're already focused\n      // and the clicked cell is the focused cell, *and* the other direction\n      // is available.\n      if (!cellData[currentDirection] || focused && row === focusedRow && col === focusedCol && cellData[other]) {\n        setCurrentDirection(other);\n        direction = other;\n      }\n      setCurrentNumber((_a = cellData[direction]) !== null && _a !== void 0 ? _a : '');\n    }\n    focus();\n  }, [currentDirection, focus, focused, focusedCol, focusedRow]);\n  const handleInputClick = (0, react_1.useCallback)((/* event */\n  ) => {\n    // *don't* event.preventDefault(), because we want the input to actually\n    // take focus\n    var _a;\n    // Like general cell-clicks, cliking on the input can change direction.\n    // Unlike cell clicks, we *know* we're clicking on the already-focused\n    // cell!\n    const other = (0, util_1.otherDirection)(currentDirection);\n    const cellData = getCellData(focusedRow, focusedCol);\n    let direction = currentDirection;\n    if (focused && cellData[other]) {\n      setCurrentDirection(other);\n      direction = other;\n    }\n    setCurrentNumber((_a = cellData[direction]) !== null && _a !== void 0 ? _a : '');\n    focus();\n  }, [currentDirection, focus, focused, focusedCol, focusedRow, getCellData]);\n  const handleClueSelected = (0, react_1.useCallback)((direction, number) => {\n    const info = clues === null || clues === void 0 ? void 0 : clues[direction].find(clue => clue.number === number);\n    if (!info) {\n      return;\n    }\n    // console.log('CrosswordProvider.handleClueSelected', { info });\n    // TODO: sanity-check info?\n    moveTo(info.row, info.col, direction);\n    focus();\n    if (onClueSelected) {\n      onClueSelected(direction, number);\n    }\n  }, [clues, focus, moveTo, onClueSelected]);\n  const registerFocusHandler = (0, react_1.useCallback)(focusHandler => {\n    // console.log('CrosswordProvider.registerFocusHandler() called', {\n    //   name: focusHandler?.name ?? '(NULL)',\n    //   focusHandler,\n    // });\n    // *If* registeredFocusHandler is implemented as state, realize that we\n    // can't simply pass it to the setter... the useState React setter would\n    // *invoke* the function and take the return value!  So, we would have\n    // to wrap it in a functional setter (setState(() => focusHandler)).\n    // But, since we're using a Ref, this is just a simple assignment!\n    registeredFocusHandler.current = focusHandler;\n  }, []);\n  // imperative commands...\n  (0, react_1.useImperativeHandle)(ref, () => ({\n    /**\n     * Sets focus to the crossword component.\n     */\n    focus,\n    /**\n     * Resets the entire crossword; clearing all answers in the grid and\n     * also any persisted data.\n     */\n    reset: () => {\n      setGridData((0, immer_1.default)(draft => {\n        draft.forEach(rowData => {\n          rowData.forEach(cellData => {\n            if (cellData.used) {\n              cellData.guess = '';\n            }\n          });\n        });\n      }));\n      setClues((0, immer_1.default)(draft => {\n        util_1.bothDirections.forEach(direction => {\n          var _a;\n          (_a = draft === null || draft === void 0 ? void 0 : draft[direction]) === null || _a === void 0 ? void 0 : _a.forEach(clueInfo => {\n            delete clueInfo.complete;\n            delete clueInfo.correct;\n          });\n        });\n      }));\n      if (useStorage) {\n        (0, util_1.clearGuesses)(storageKey || defaultStorageKey);\n      }\n    },\n    /**\n     * Fills all the answers in the grid and calls the `onLoadedCorrect`\n     * callback with _**every**_ answer.\n     */\n    fillAllAnswers: () => {\n      setGridData((0, immer_1.default)(draft => {\n        draft.forEach(rowData => {\n          rowData.forEach(cellData => {\n            if (cellData.used) {\n              cellData.guess = cellData.answer;\n            }\n          });\n        });\n      }));\n      setClues((0, immer_1.default)(draft => {\n        util_1.bothDirections.forEach(direction => {\n          draft === null || draft === void 0 ? void 0 : draft[direction].forEach(clueInfo => {\n            clueInfo.complete = true;\n            clueInfo.correct = true;\n          });\n        });\n      }));\n      // trigger onLoadedCorrect with every clue!\n      if (onLoadedCorrect) {\n        const loadedCorrect = [];\n        util_1.bothDirections.forEach(direction => {\n          clues === null || clues === void 0 ? void 0 : clues[direction].forEach(_ref4 => {\n            let {\n              number,\n              answer\n            } = _ref4;\n            loadedCorrect.push([direction, number, answer]);\n          });\n        });\n        onLoadedCorrect(loadedCorrect);\n      }\n    },\n    /**\n     * Returns whether the crossword is entirely correct or not.\n     */\n    isCrosswordCorrect: () => crosswordCorrect,\n    /**\n     * Sets the “guess” character for a specific grid position.\n     *\n     * @since 4.1.0\n     */\n    setGuess: (row, col, guess) => {\n      // REVIEW: should we force-case this?\n      setCellCharacter(row, col, guess.toUpperCase());\n    }\n  }), [clues, crosswordCorrect, focus, onLoadedCorrect, setCellCharacter, storageKey, useStorage]);\n  const crosswordContext = (0, react_1.useMemo)(() => ({\n    rows,\n    cols,\n    gridData,\n    clues,\n    handleInputKeyDown,\n    handleInputChange,\n    handleCellClick,\n    handleInputClick,\n    handleClueSelected,\n    registerFocusHandler,\n    focused,\n    selectedPosition: {\n      row: focusedRow,\n      col: focusedCol\n    },\n    selectedDirection: currentDirection,\n    selectedNumber: currentNumber,\n    crosswordCorrect\n  }), [rows, cols, gridData, clues, handleInputKeyDown, handleInputChange, handleCellClick, handleInputClick, handleClueSelected, registerFocusHandler, focused, focusedRow, focusedCol, currentDirection, currentNumber, crosswordCorrect]);\n  return (0, jsx_runtime_1.jsx)(styled_components_1.ThemeProvider, Object.assign({\n    theme: finalTheme\n  }, {\n    children: (0, jsx_runtime_1.jsx)(context_1.CrosswordContext.Provider, Object.assign({\n      value: crosswordContext\n    }, {\n      children: children\n    }))\n  }));\n});\nexports.default = CrosswordProvider;\nCrosswordProvider.displayName = 'CrosswordProvider';\nCrosswordProvider.propTypes = exports.crosswordProviderPropTypes;\nCrosswordProvider.defaultProps = {\n  theme: undefined,\n  useStorage: true,\n  storageKey: undefined,\n  onAnswerComplete: undefined,\n  onAnswerCorrect: undefined,\n  onCorrect: undefined,\n  onAnswerIncorrect: undefined,\n  onLoadedCorrect: undefined,\n  onCrosswordComplete: undefined,\n  onCrosswordCorrect: undefined,\n  onCellChange: undefined,\n  onClueSelected: undefined,\n  children: undefined\n};","map":{"version":3,"names":["react_1","__importStar","require","prop_types_1","__importDefault","immer_1","styled_components_1","context_1","types_1","util_1","defaultStorageKey","exports","crosswordProviderPropTypes","data","cluesInputShapeOriginal","isRequired","theme","default","shape","allowNonSquare","bool","columnBreakpoint","string","gridBackground","cellBackground","cellBorder","textColor","numberColor","focusBackground","highlightBackground","useStorage","storageKey","onAnswerComplete","func","onAnswerCorrect","onCorrect","onAnswerIncorrect","onLoadedCorrect","onCrosswordComplete","onCrosswordCorrect","onCellChange","onClueSelected","children","node","defaultTheme","CrosswordProvider","forwardRef","_ref","ref","contextTheme","useContext","ThemeContext","finalTheme","useMemo","Object","assign","rows","cols","gridData","masterGridData","clues","masterClues","_a","createGridData","setGridData","useState","setClues","registeredFocusHandler","useRef","focused","setFocused","focusedRow","setFocusedRow","focusedCol","setFocusedCol","currentDirection","setCurrentDirection","currentNumber","setCurrentNumber","bulkChange","setBulkChange","checkQueue","setCheckQueue","getCellData","useCallback","row","col","used","outOfBounds","setCellCharacter","char","cell","Error","guess","draft","push","notifyAnswerComplete","direction","number","correct","answer","checkCorrectness","bothDirections","forEach","across","isAcross","info","complete","i","length","checkCell","clueInfo","find","useEffect","_ref2","crosswordComplete","crosswordCorrect","every","focus","current","console","warn","moveTo","directionOverride","candidate","otherDirection","moveRelative","dRow","dCol","moveForward","moveBackward","handleSingleCharacter","toUpperCase","handleInputKeyDown","event","ctrlKey","altKey","metaKey","preventDefault","key","other","cellData","handleInputChange","target","value","substring","newGridData","map","newCluesData","clue","down","loadGuesses","flatMap","dir","_ref3","saveGuesses","handleCellClick","handleInputClick","handleClueSelected","registerFocusHandler","focusHandler","useImperativeHandle","reset","rowData","clearGuesses","fillAllAnswers","loadedCorrect","_ref4","isCrosswordCorrect","setGuess","crosswordContext","selectedPosition","selectedDirection","selectedNumber","jsx_runtime_1","jsx","ThemeProvider","CrosswordContext","Provider","displayName","propTypes","defaultProps","undefined"],"sources":["C:\\Users\\Nabila\\Desktop\\aksara\\node_modules\\@jaredreisinger\\react-crossword\\src\\CrosswordProvider.tsx"],"sourcesContent":["/* eslint-disable no-console */\n\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport PropTypes from 'prop-types';\n\nimport produce from 'immer';\nimport { ThemeContext, ThemeProvider } from 'styled-components';\n\nimport { CrosswordContext, CrosswordContextType } from './context';\nimport {\n  AnswerTuple,\n  CluesData,\n  CluesInput,\n  cluesInputShapeOriginal,\n  Direction,\n  EnhancedProps,\n  FocusHandler,\n  GridPosition,\n  GridData,\n  UsedCellData,\n  CellData,\n  UnusedCellData,\n} from './types';\nimport {\n  bothDirections,\n  clearGuesses,\n  createGridData,\n  isAcross,\n  loadGuesses,\n  otherDirection,\n  saveGuesses,\n} from './util';\n\nconst defaultStorageKey = 'guesses';\n\nexport const crosswordProviderPropTypes = {\n  /**\n   * clue/answer data; see <a\n   * href=\"#/Configuration%20and%20customization/Clue%20input%20format\">Clue\n   * input format</a> for details.\n   */\n  data: cluesInputShapeOriginal.isRequired,\n\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: PropTypes.shape({\n    /**\n     * whether to allow a non-square rendering\n     * @since 5.1.0\n     */\n    allowNonSquare: PropTypes.bool,\n\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: PropTypes.string,\n\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: PropTypes.string,\n    /**  background for an answer cell */\n    cellBackground: PropTypes.string,\n    /** border for an answer cell */\n    cellBorder: PropTypes.string,\n    /** color for answer text (entered by the player) */\n    textColor: PropTypes.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: PropTypes.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: PropTypes.string,\n    /**\n     * background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue\n     */\n    highlightBackground: PropTypes.string,\n  }),\n\n  /** whether to use browser storage to persist the player's work-in-progress */\n  useStorage: PropTypes.bool,\n\n  /**\n   * a custom storage key to use for persistence; defaults to \"guesses\" when not\n   * provided\n   */\n  storageKey: PropTypes.string,\n\n  /**\n   * callback function that fires when a player completes an answer, whether\n   * correct or not; called with `(direction, number, correct, answer)`\n   * arguments, where `direction` is `'across'` or `'down'`, `number` is the\n   * clue number as text (like `'1'`), `correct` is whether the guessed answer\n   * is correct and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerComplete: PropTypes.func,\n\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)\n   */\n  onAnswerCorrect: PropTypes.func,\n\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @deprecated 4.3.0; being replaced by `onAnswerCorrect` (to reduce\n   * ambiguity)\n   */\n  onCorrect: PropTypes.func,\n\n  /**\n   * callback function that fires when a player answers a clue *in*correctly;\n   * called with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerIncorrect: PropTypes.func,\n\n  /**\n   * callback function that's called when a crossword is loaded, to batch up\n   * correct answers loaded from storage; passed an array of the same values\n   * that `onCorrect` would recieve\n   */\n  onLoadedCorrect: PropTypes.func,\n\n  /**\n   * callback function that's called when the overall crossword is complete,\n   * whether correct or not; called with `(correct)` argument, a boolean which\n   * indicates whether the crossword is correct or not.\n   */\n  onCrosswordComplete: PropTypes.func,\n\n  /**\n   * callback function that's called when the overall crossword is completely\n   * correct (or not)\n   *\n   * NOTE: this will be deprecated for `onCrosswordComplete` in the future.\n   */\n  onCrosswordCorrect: PropTypes.func,\n\n  /**\n   * callback function called when a cell changes (e.g. when the user types a\n   * letter); called with `(row, col, char)` arguments, where the `row` and\n   * `column` are the 0-based position of the cell, and `char` is the character\n   * typed (already massaged into upper-case)\n   */\n  onCellChange: PropTypes.func,\n\n  /**\n   * callback function called when a clue is selected\n   */\n  onClueSelected: PropTypes.func,\n\n  children: PropTypes.node,\n};\n\nexport type CrosswordProviderProps = EnhancedProps<\n  typeof crosswordProviderPropTypes,\n  {\n    /**\n     * clue/answer data; see <a\n     * href=\"#/Configuration%20and%20customization/Clue%20input%20format\">Clue\n     * input format</a> for details.\n     */\n    data: CluesInput;\n\n    /**\n     * callback function that fires when a player completes an answer, whether\n     * correct or not; called with `(direction, number, correct, answer)`\n     * arguments, where `direction` is `'across'` or `'down'`, `number` is the\n     * clue number as text (like `'1'`), `correct` is whether the guessed answer\n     * is correct and `answer` is the (actual and correct) answer itself\n     *\n     * @since 4.3.0\n     */\n    onAnswerComplete?: (\n      direction: Direction,\n      number: string,\n      correct: boolean,\n      answer: string\n    ) => void;\n\n    /**\n     * callback function that fires when a player answers a clue correctly;\n     * called with `(direction, number, answer)` arguments, where `direction` is\n     * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n     * and `answer` is the answer itself\n     *\n     * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)\n     */\n    onAnswerCorrect?: (\n      direction: Direction,\n      number: string,\n      answer: string\n    ) => void;\n\n    /**\n     * callback function that fires when a player answers a clue correctly;\n     * called with `(direction, number, answer)` arguments, where `direction` is\n     * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n     * and `answer` is the answer itself\n     *\n     * NOTE: this is the original/previous name for what is now being called\n     * `onAnswerCorrect` (to reduce ambiguity).  It will be deprecated in the\n     * future.\n     */\n    onCorrect?: (direction: Direction, number: string, answer: string) => void;\n\n    /**\n     * callback function that fires when a player answers a clue *in*correctly;\n     * called with `(direction, number, answer)` arguments, where `direction` is\n     * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n     * and `answer` is the (actual and correct) answer itself\n     *\n     * @since 4.3.0\n     */\n    onAnswerIncorrect?: (\n      direction: Direction,\n      number: string,\n      answer: string\n    ) => void;\n\n    /**\n     * callback function that's called when a crossword is loaded, to batch up\n     * correct answers loaded from storage; passed an array of the same values\n     * that `onCorrect` would recieve\n     */\n    onLoadedCorrect?: (loaded: AnswerTuple[]) => void;\n\n    /**\n     * callback function that's called when the overall crossword is complete,\n     * whether correct or not; called with `(correct)` argument, a boolean which\n     * indicates whether the crossword is correct or not.\n     */\n    onCrosswordComplete?: (correct: boolean) => void;\n\n    /**\n     * callback function that's called when the overall crossword is completely\n     * correct (or not)\n     *\n     * NOTE: this will be deprecated for `onCrosswordComplete` in the future.\n     */\n    onCrosswordCorrect?: (isCorrect: boolean) => void;\n\n    /**\n     * callback function called when a cell changes (e.g. when the user types a\n     * letter); called with `(row, col, char)` arguments, where the `row` and\n     * `column` are the 0-based position of the cell, and `char` is the\n     * character typed (already massaged into upper-case)\n     */\n    onCellChange?: (row: number, col: number, char: string) => void;\n\n    /**\n     * callback function called when a clue is selected\n     */\n    onClueSelected?: (direction: Direction, number: string) => void;\n  }\n>;\n\nexport interface CrosswordProviderImperative {\n  /**\n   * Sets focus to the crossword component.\n   */\n  focus: () => void;\n\n  /**\n   * Resets the entire crossword; clearing all answers in the grid and\n   * also any persisted data.\n   */\n  reset: () => void;\n\n  /**\n   * Fills all the answers in the grid and calls the `onLoadedCorrect`\n   * callback with _**every**_ answer.\n   */\n  fillAllAnswers: () => void;\n\n  /**\n   * Returns whether the crossword is entirely correct or not.\n   */\n  isCrosswordCorrect: () => boolean;\n\n  /**\n   * Sets the “guess” character for a specific grid position.\n   *\n   * @since 4.1.0\n   */\n  setGuess: (row: number, col: number, guess: string) => void;\n}\n\nconst defaultTheme: CrosswordProviderProps['theme'] = {\n  allowNonSquare: false,\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)',\n};\n\n/**\n * The fundamental logic and data management component for react-crossword.\n * Prior to 4.0, puzzle management was built into the `Crossword` component.  As\n * of 4.0, the logic implementation has been refactored such that `Crossword`\n * leverages `CrosswordProvider` to do the heavy lifting.\n *\n * @since 4.0\n */\nconst CrosswordProvider = React.forwardRef<\n  CrosswordProviderImperative,\n  CrosswordProviderProps\n>(\n  (\n    {\n      data,\n      theme,\n      onAnswerComplete,\n      onAnswerCorrect,\n      onCorrect,\n      onAnswerIncorrect,\n      onLoadedCorrect,\n      onCrosswordComplete,\n      onCrosswordCorrect,\n      onCellChange,\n      onClueSelected,\n      useStorage,\n      storageKey,\n      children,\n    },\n    ref\n  ) => {\n    const contextTheme =\n      useContext<CrosswordProviderProps['theme']>(ThemeContext);\n\n    // The final theme is the merger of three values: the \"theme\" property\n    // passed to the component (which takes precedence), any values from\n    // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n    // needed ones that are missing.  (We create this in standard last-one-wins\n    // order in Javascript, of course.)\n    const finalTheme = useMemo(\n      () => ({ ...defaultTheme, ...contextTheme, ...theme }),\n      [contextTheme, theme]\n    );\n\n    // The original Crossword implementation used separate state to track size\n    // and grid data, and conflated the clues-input-data-based grid data and the\n    // player input guesses.  Let's see if we can keep the clues-input and\n    // player data segregated.\n    const {\n      rows,\n      cols,\n      gridData: masterGridData,\n      clues: masterClues,\n    } = useMemo(\n      () => createGridData(data, finalTheme.allowNonSquare ?? false),\n      [data, finalTheme.allowNonSquare]\n    );\n\n    const [gridData, setGridData] = useState<GridData>([]);\n    const [clues, setClues] = useState<CluesData | undefined>();\n\n    // We can't seem to use state to track the registeredFocusHandler, because\n    // there seems to be a delay in 'focus' being usable after it's set.  We use\n    // a Ref instead.\n    const registeredFocusHandler = useRef<FocusHandler | null>(null);\n\n    // interactive player state\n    const [focused, setFocused] = useState(false);\n    const [focusedRow, setFocusedRow] = useState(0); // rename to selectedRow?\n    const [focusedCol, setFocusedCol] = useState(0);\n    const [currentDirection, setCurrentDirection] =\n      useState<Direction>('across');\n    const [currentNumber, setCurrentNumber] = useState('1');\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [bulkChange, setBulkChange] = useState<string | null>(null);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [checkQueue, setCheckQueue] = useState<GridPosition[]>([]);\n\n    // This *internal* getCellData assumes that it's only ever asked for a valid\n    // cell (one that's used).\n    const getCellData = useCallback(\n      (row: number, col: number) => {\n        if (row >= 0 && row < rows && col >= 0 && col < cols) {\n          return gridData[row][col];\n        }\n\n        // fake cellData to represent \"out of bounds\"\n        return { row, col, used: false, outOfBounds: true } as GridPosition &\n          UnusedCellData;\n      },\n      [cols, gridData, rows]\n    );\n\n    const setCellCharacter = useCallback(\n      (row: number, col: number, char: string) => {\n        const cell = getCellData(row, col);\n\n        if (!cell.used) {\n          throw new Error('unexpected setCellCharacter call');\n        }\n\n        // If the character is already the cell's guess, there's nothing to do.\n        if (cell.guess === char) {\n          return;\n        }\n\n        // update the gridData with the guess\n        setGridData(\n          produce((draft) => {\n            (draft[row][col] as UsedCellData).guess = char;\n          })\n        );\n\n        // push the row/col for checking!\n        setCheckQueue(\n          produce((draft) => {\n            draft.push({ row, col });\n          })\n        );\n\n        if (onCellChange) {\n          onCellChange(row, col, char);\n        }\n      },\n      [getCellData, onCellChange]\n    );\n\n    const notifyAnswerComplete = useCallback(\n      (\n        direction: Direction,\n        number: string,\n        correct: boolean,\n        answer: string\n      ) => {\n        if (onAnswerComplete) {\n          onAnswerComplete(direction, number, correct, answer);\n        }\n\n        if (correct) {\n          if (onAnswerCorrect) {\n            onAnswerCorrect(direction, number, answer);\n          }\n\n          // NOTE: onCorrect to be (eventually) deprecated\n          if (onCorrect) {\n            onCorrect(direction, number, answer);\n          }\n        } else if (onAnswerIncorrect) {\n          onAnswerIncorrect(direction, number, answer);\n        }\n      },\n      [onAnswerComplete, onAnswerCorrect, onAnswerIncorrect, onCorrect]\n    );\n\n    const checkCorrectness = useCallback(\n      (row: number, col: number) => {\n        const cell = getCellData(row, col);\n        if (!cell.used) {\n          // Because this is in an internal callback, and we only call it with a\n          // valid cell (row/col), the throw line isn't testable... so we ignore\n          // it.\n          /* istanbul ignore next */\n          throw new Error('unexpected unused cell');\n        }\n\n        // check all the cells for both across and down answers that use this\n        // cell\n        bothDirections.forEach((direction) => {\n          const across = isAcross(direction);\n          const number = cell[direction];\n          if (!number) {\n            return;\n          }\n\n          const info = data[direction][number];\n\n          // We send correct/incorrect messages, but *only* if every cell in the\n          // answer is filled out; there's no point in reporting \"incorrect\"\n          // when the answer is simply incomplete.\n          let complete = true;\n          let correct = true;\n\n          for (let i = 0; i < info.answer.length; i++) {\n            const checkCell = getCellData(\n              info.row + (across ? 0 : i),\n              info.col + (across ? i : 0)\n            ) as UsedCellData;\n\n            if (!checkCell.guess) {\n              complete = false;\n              correct = false;\n              break;\n            }\n\n            if (checkCell.guess !== checkCell.answer) {\n              correct = false;\n            }\n          }\n\n          // update the clue state\n          setClues(\n            produce((draft) => {\n              if (draft) {\n                const clueInfo = draft[direction].find(\n                  (i) => i.number === number\n                );\n                if (clueInfo) {\n                  clueInfo.complete = complete;\n                  clueInfo.correct = correct;\n                }\n              }\n            })\n          );\n\n          if (complete) {\n            notifyAnswerComplete(direction, number, correct, info.answer);\n          }\n        });\n      },\n      [data, getCellData, notifyAnswerComplete]\n    );\n\n    // Any time the checkQueue changes, call checkCorrectness!\n    useEffect(() => {\n      if (checkQueue.length === 0) {\n        return;\n      }\n\n      checkQueue.forEach(({ row, col }) => checkCorrectness(row, col));\n      setCheckQueue([]);\n    }, [checkQueue, checkCorrectness]);\n\n    // Any time the clues change, determine if they are all complete/correct or\n    // not.\n    const { crosswordComplete, crosswordCorrect } = useMemo(() => {\n      const complete = !!(\n        clues &&\n        bothDirections.every((direction) =>\n          clues[direction].every((clueInfo) => clueInfo.complete)\n        )\n      );\n\n      const correct =\n        complete &&\n        !!(\n          clues &&\n          bothDirections.every((direction) =>\n            clues[direction].every((clueInfo) => clueInfo.correct)\n          )\n        );\n      // console.log('setting crossword correct', { clues, correct });\n      return { crosswordComplete: complete, crosswordCorrect: correct };\n    }, [clues]);\n\n    // Let the consumer know everything's correct (or not) if they've asked to\n    // be informed.\n    useEffect(() => {\n      if (crosswordComplete) {\n        if (onCrosswordComplete) {\n          onCrosswordComplete(crosswordCorrect);\n        }\n        if (onCrosswordCorrect) {\n          onCrosswordCorrect(crosswordCorrect);\n        }\n      }\n    }, [\n      crosswordComplete,\n      crosswordCorrect,\n      onCrosswordComplete,\n      onCrosswordCorrect,\n    ]);\n\n    // focus and movement\n    const focus = useCallback(() => {\n      // console.log('CrosswordProvider.focus() called...');\n\n      // If there's a registered focus handler, use it!\n      if (registeredFocusHandler.current) {\n        // console.log('calling registered focus handler...');\n        registeredFocusHandler.current();\n        setFocused(true);\n      } else {\n        console.warn(\n          'CrosswordProvider: focus() has no registered handler to call!'\n        );\n      }\n    }, []);\n\n    const moveTo = useCallback(\n      (row: number, col: number, directionOverride?: Direction) => {\n        let direction = directionOverride ?? currentDirection;\n        const candidate = getCellData(row, col);\n\n        if (!candidate.used) {\n          return false;\n        }\n\n        // If we try to move to a cell with a direction it doesn't support,\n        // switch to the other direction.  There is no codepath that can test\n        // this, though, as this callback isn't exposed, and we only call it in\n        // ways that guarantee that direction is valid.\n        if (!candidate[direction]) {\n          /* istanbul ignore next */\n          direction = otherDirection(direction);\n        }\n\n        setFocusedRow(row);\n        setFocusedCol(col);\n        setCurrentDirection(direction);\n        setCurrentNumber(candidate[direction] ?? '');\n\n        return candidate;\n      },\n      [currentDirection, getCellData]\n    );\n\n    const moveRelative = useCallback(\n      (dRow: number, dCol: number) => {\n        // We expect *only* one of dRow or dCol to have a non-zero value, and\n        // that's the direction we will \"prefer\".  If *both* are set (or zero),\n        // we don't change the direction.\n        let direction: Direction | undefined;\n        if (dRow !== 0 && dCol === 0) {\n          direction = 'down';\n        } else if (dRow === 0 && dCol !== 0) {\n          direction = 'across';\n        }\n\n        const cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);\n\n        return cell;\n      },\n      [focusedRow, focusedCol, moveTo]\n    );\n\n    const moveForward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : 1, across ? 1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    const moveBackward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : -1, across ? -1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    // keyboard handling\n    const handleSingleCharacter = useCallback(\n      (char: string) => {\n        setCellCharacter(focusedRow, focusedCol, char.toUpperCase());\n        moveForward();\n      },\n      [focusedRow, focusedCol, setCellCharacter, moveForward]\n    );\n\n    // We use the keydown event for control/arrow keys, but not for textual\n    // input, because it's hard to suss out when a key is \"regular\" or not.\n    const handleInputKeyDown = useCallback<\n      React.KeyboardEventHandler<HTMLInputElement>\n    >(\n      (event) => {\n        // if ctrl, alt, or meta are down, ignore the event (let it bubble)\n        if (event.ctrlKey || event.altKey || event.metaKey) {\n          return;\n        }\n\n        let preventDefault = true;\n        const { key } = event;\n        // console.log('CROSSWORD KEYDOWN', event.key);\n\n        // FUTURE: should we \"jump\" over black space?  That might help some for\n        // keyboard users.\n        switch (key) {\n          case 'ArrowUp':\n            moveRelative(-1, 0);\n            break;\n\n          case 'ArrowDown':\n            moveRelative(1, 0);\n            break;\n\n          case 'ArrowLeft':\n            moveRelative(0, -1);\n            break;\n\n          case 'ArrowRight':\n            moveRelative(0, 1);\n            break;\n\n          case ' ': // treat space like tab?\n          case 'Tab': {\n            const other = otherDirection(currentDirection);\n            const cellData = getCellData(\n              focusedRow,\n              focusedCol\n            ) as UsedCellData;\n            if (cellData[other]) {\n              setCurrentDirection(other);\n              setCurrentNumber(cellData[other] ?? '');\n            }\n            break;\n          }\n\n          // Backspace: delete the current cell, and move to the previous cell\n          // Delete:    delete the current cell, but don't move\n          case 'Backspace':\n          case 'Delete': {\n            setCellCharacter(focusedRow, focusedCol, '');\n            if (key === 'Backspace') {\n              moveBackward();\n            }\n            break;\n          }\n\n          case 'Home':\n          case 'End': {\n            // move to beginning/end of this entry?\n            const info = data[currentDirection][currentNumber];\n            const {\n              answer: { length },\n            } = info;\n            let { row, col } = info;\n            if (key === 'End') {\n              const across = isAcross(currentDirection);\n              if (across) {\n                col += length - 1;\n              } else {\n                row += length - 1;\n              }\n            }\n\n            moveTo(row, col);\n            break;\n          }\n\n          default:\n            // It would be nice to handle \"regular\" characters with onInput, but\n            // that is still experimental, so we can't count on it.  Instead, we\n            // assume that only \"length 1\" values are regular.\n            if (key.length !== 1) {\n              preventDefault = false;\n              break;\n            }\n\n            handleSingleCharacter(key);\n            break;\n        }\n\n        if (preventDefault) {\n          event.preventDefault();\n        }\n      },\n      [\n        moveRelative,\n        handleSingleCharacter,\n        currentDirection,\n        getCellData,\n        focusedRow,\n        focusedCol,\n        setCellCharacter,\n        moveBackward,\n        data,\n        currentNumber,\n        moveTo,\n      ]\n    );\n\n    const handleInputChange = useCallback<\n      React.ChangeEventHandler<HTMLInputElement>\n    >((event) => {\n      event.preventDefault();\n      setBulkChange(event.target.value);\n    }, []);\n\n    useEffect(() => {\n      if (!bulkChange) {\n        return;\n      }\n\n      // handle bulkChange by updating a character at a time (this lets us\n      // leverage the existing character-entry logic).\n      handleSingleCharacter(bulkChange[0]);\n      setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));\n    }, [bulkChange, handleSingleCharacter]);\n\n    // When the clues *input* data changes, reset/reload the player data\n    useEffect(() => {\n      // deep-clone the grid data...\n      const newGridData = masterGridData.map((row) =>\n        row.map((cell) => ({ ...cell }))\n      );\n\n      // deep-clone the clue data...\n      const newCluesData: CluesData = {\n        across: masterClues.across.map((clue) => ({ ...clue })),\n        down: masterClues.down.map((clue) => ({ ...clue })),\n      };\n\n      if (useStorage) {\n        loadGuesses(newGridData, storageKey || defaultStorageKey);\n      }\n\n      setClues(newCluesData);\n      setGridData(newGridData);\n\n      // Check all of the clues to see if any were correct... but only if we\n      // loaded guesses.  Since the current implementation relies on state, we\n      // leverage the checkQueue to run through all the clues/guesses.\n      //\n      // Really, the ideal thing to do would be to write the checking-logic in a\n      // way that it doesn't assume the data is already in state... that would\n      // allow us to check everything directly, and simply set the same state\n      // that checkCorrectness() does, *and* properly call onLoadedCorrect(). As\n      // it is, this implementation can cause some answers to mentioned in\n      // onCorrect() more than once (any time an across answer starts inside a\n      // down answer, or vice versa.)\n      if (useStorage) {\n        setCheckQueue(\n          bothDirections.flatMap((dir) =>\n            // simply use the row/col that starts each answer.\n            newCluesData[dir].map(({ row, col }) => ({ row, col }))\n          )\n        );\n      }\n\n      // Should we start with 1-across highlighted/focused?\n\n      // TODO: track input-field focus so we don't draw highlight when we're not\n      // really focused, *and* use first actual clue (whether across or down?)\n      setFocusedRow(0);\n      setFocusedCol(0);\n      setCurrentDirection('across');\n      setCurrentNumber('1');\n    }, [masterClues, masterGridData, storageKey, useStorage]);\n\n    // save the guesses any time they change...\n    useEffect(() => {\n      if (gridData === null || !useStorage) {\n        return;\n      }\n\n      saveGuesses(gridData, storageKey || defaultStorageKey);\n    }, [gridData, storageKey, useStorage]);\n\n    const handleCellClick = useCallback(\n      (cellData: CellData) => {\n        if (cellData.used) {\n          const { row, col } = cellData;\n          const other = otherDirection(currentDirection);\n\n          // should this use moveTo?\n          setFocusedRow(row);\n          setFocusedCol(col);\n\n          let direction = currentDirection;\n\n          // We switch to the \"other\" direction if (a) the current direction\n          // isn't available in the clicked cell, or (b) we're already focused\n          // and the clicked cell is the focused cell, *and* the other direction\n          // is available.\n          if (\n            !cellData[currentDirection] ||\n            (focused &&\n              row === focusedRow &&\n              col === focusedCol &&\n              cellData[other])\n          ) {\n            setCurrentDirection(other);\n            direction = other;\n          }\n\n          setCurrentNumber(cellData[direction] ?? '');\n        }\n\n        focus();\n      },\n      [currentDirection, focus, focused, focusedCol, focusedRow]\n    );\n\n    const handleInputClick = useCallback<\n      React.MouseEventHandler<HTMLInputElement>\n    >(\n      (/* event */) => {\n        // *don't* event.preventDefault(), because we want the input to actually\n        // take focus\n\n        // Like general cell-clicks, cliking on the input can change direction.\n        // Unlike cell clicks, we *know* we're clicking on the already-focused\n        // cell!\n        const other = otherDirection(currentDirection);\n        const cellData = getCellData(focusedRow, focusedCol) as UsedCellData;\n\n        let direction = currentDirection;\n\n        if (focused && cellData[other]) {\n          setCurrentDirection(other);\n          direction = other;\n        }\n\n        setCurrentNumber(cellData[direction] ?? '');\n        focus();\n      },\n      [currentDirection, focus, focused, focusedCol, focusedRow, getCellData]\n    );\n\n    const handleClueSelected = useCallback(\n      (direction: Direction, number: string) => {\n        const info = clues?.[direction].find((clue) => clue.number === number);\n\n        if (!info) {\n          return;\n        }\n\n        // console.log('CrosswordProvider.handleClueSelected', { info });\n        // TODO: sanity-check info?\n        moveTo(info.row, info.col, direction);\n        focus();\n\n        if (onClueSelected) {\n          onClueSelected(direction, number);\n        }\n      },\n      [clues, focus, moveTo, onClueSelected]\n    );\n\n    const registerFocusHandler = useCallback(\n      (focusHandler: FocusHandler | null) => {\n        // console.log('CrosswordProvider.registerFocusHandler() called', {\n        //   name: focusHandler?.name ?? '(NULL)',\n        //   focusHandler,\n        // });\n\n        // *If* registeredFocusHandler is implemented as state, realize that we\n        // can't simply pass it to the setter... the useState React setter would\n        // *invoke* the function and take the return value!  So, we would have\n        // to wrap it in a functional setter (setState(() => focusHandler)).\n        // But, since we're using a Ref, this is just a simple assignment!\n        registeredFocusHandler.current = focusHandler;\n      },\n      []\n    );\n\n    // imperative commands...\n    useImperativeHandle(\n      ref,\n      () => ({\n        /**\n         * Sets focus to the crossword component.\n         */\n        focus,\n\n        /**\n         * Resets the entire crossword; clearing all answers in the grid and\n         * also any persisted data.\n         */\n        reset: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = '';\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft?.[direction]?.forEach((clueInfo) => {\n                  delete clueInfo.complete;\n                  delete clueInfo.correct;\n                });\n              });\n            })\n          );\n\n          if (useStorage) {\n            clearGuesses(storageKey || defaultStorageKey);\n          }\n        },\n\n        /**\n         * Fills all the answers in the grid and calls the `onLoadedCorrect`\n         * callback with _**every**_ answer.\n         */\n        fillAllAnswers: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = cellData.answer;\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft?.[direction].forEach((clueInfo) => {\n                  clueInfo.complete = true;\n                  clueInfo.correct = true;\n                });\n              });\n            })\n          );\n\n          // trigger onLoadedCorrect with every clue!\n          if (onLoadedCorrect) {\n            const loadedCorrect: AnswerTuple[] = [];\n            bothDirections.forEach((direction) => {\n              clues?.[direction].forEach(({ number, answer }) => {\n                loadedCorrect.push([direction, number, answer]);\n              });\n            });\n\n            onLoadedCorrect(loadedCorrect);\n          }\n        },\n\n        /**\n         * Returns whether the crossword is entirely correct or not.\n         */\n        isCrosswordCorrect: () => crosswordCorrect,\n\n        /**\n         * Sets the “guess” character for a specific grid position.\n         *\n         * @since 4.1.0\n         */\n        setGuess: (row: number, col: number, guess: string) => {\n          // REVIEW: should we force-case this?\n          setCellCharacter(row, col, guess.toUpperCase());\n        },\n      }),\n      [\n        clues,\n        crosswordCorrect,\n        focus,\n        onLoadedCorrect,\n        setCellCharacter,\n        storageKey,\n        useStorage,\n      ]\n    );\n\n    const crosswordContext = useMemo<CrosswordContextType>(\n      () => ({\n        rows,\n        cols,\n        gridData,\n        clues,\n\n        handleInputKeyDown,\n        handleInputChange,\n        handleCellClick,\n        handleInputClick,\n        handleClueSelected,\n        registerFocusHandler,\n\n        focused,\n        selectedPosition: { row: focusedRow, col: focusedCol },\n        selectedDirection: currentDirection,\n        selectedNumber: currentNumber,\n\n        crosswordCorrect,\n      }),\n      [\n        rows,\n        cols,\n        gridData,\n        clues,\n        handleInputKeyDown,\n        handleInputChange,\n        handleCellClick,\n        handleInputClick,\n        handleClueSelected,\n        registerFocusHandler,\n        focused,\n        focusedRow,\n        focusedCol,\n        currentDirection,\n        currentNumber,\n        crosswordCorrect,\n      ]\n    );\n\n    return (\n      <ThemeProvider theme={finalTheme}>\n        <CrosswordContext.Provider value={crosswordContext}>\n          {children}\n        </CrosswordContext.Provider>\n      </ThemeProvider>\n    );\n  }\n);\n\nexport default CrosswordProvider;\n\nCrosswordProvider.displayName = 'CrosswordProvider';\nCrosswordProvider.propTypes = crosswordProviderPropTypes;\nCrosswordProvider.defaultProps = {\n  theme: undefined,\n  useStorage: true,\n  storageKey: undefined,\n  onAnswerComplete: undefined,\n  onAnswerCorrect: undefined,\n  onCorrect: undefined,\n  onAnswerIncorrect: undefined,\n  onLoadedCorrect: undefined,\n  onCrosswordComplete: undefined,\n  onCrosswordCorrect: undefined,\n  onCellChange: undefined,\n  onClueSelected: undefined,\n  children: undefined,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}