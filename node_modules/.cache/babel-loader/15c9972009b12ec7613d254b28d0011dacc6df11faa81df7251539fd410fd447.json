{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findCorrectAnswers = exports.deserializeGuesses = exports.loadGuesses = exports.serializeGuesses = exports.saveGuesses = exports.clearGuesses = exports.byNumber = exports.createGridData = exports.fillClues = exports.createEmptyGrid = exports.calculateExtents = exports.otherDirection = exports.isAcross = exports.bothDirections = void 0;\nconst directionInfo = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row'\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col'\n  }\n};\nexports.bothDirections = Object.keys(directionInfo);\nfunction isAcross(direction) {\n  return direction === 'across';\n}\nexports.isAcross = isAcross;\nfunction otherDirection(direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\nexports.otherDirection = otherDirection;\nfunction calculateExtents(data, direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n  Object.entries(data[direction]).forEach(([, info]) => {\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n  const rowColMax = {\n    row: 0,\n    col: 0\n  };\n  rowColMax[dir.primary] = primaryMax;\n  rowColMax[dir.orthogonal] = orthogonalMax;\n  return rowColMax;\n}\nexports.calculateExtents = calculateExtents;\n// const emptyCellData: Partial<CellData> = {\n//   used: false,\n//   // number: undefined, // null,\n//   // answer: '',\n//   // guess: '',\n//   // row: r,\n//   // col: c,\n//   // across: '', //null,\n//   // down: '', //null,\n// } as const;\nfunction createEmptyGrid(rows, cols) {\n  const gridData = Array(rows);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < rows; r++) {\n    gridData[r] = Array(cols);\n    for (let c = 0; c < cols; c++) {\n      gridData[r][c] = {\n        // ...emptyCellData,\n        row: r,\n        col: c,\n        used: false\n      };\n    }\n  }\n  return gridData;\n}\nexports.createEmptyGrid = createEmptyGrid;\nfunction fillClues(gridData, clues, data, direction) {\n  const dir = directionInfo[direction];\n  Object.entries(data[direction]).forEach(([number, info]) => {\n    const {\n      row: rowStart,\n      col: colStart,\n      clue,\n      answer\n    } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === 'row' ? i : 0);\n      const col = colStart + (dir.primary === 'col' ? i : 0);\n      const cellData = gridData[row][col];\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n    clues[direction].push({\n      number,\n      clue,\n      answer,\n      col: colStart,\n      row: rowStart\n    });\n  });\n  clues[direction].sort(byNumber);\n}\nexports.fillClues = fillClues;\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nfunction createGridData(data, allowNonSquare) {\n  const acrossMax = calculateExtents(data, 'across');\n  const downMax = calculateExtents(data, 'down');\n  let rows = Math.max(acrossMax.row, downMax.row) + 1;\n  let cols = Math.max(acrossMax.col, downMax.col) + 1;\n  if (!allowNonSquare) {\n    const size = Math.max(rows, cols);\n    rows = size;\n    cols = size;\n  }\n  const gridData = createEmptyGrid(rows, cols);\n  // Now fill with answers... and also collect the clues\n  const clues = {\n    across: [],\n    down: []\n  };\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n  return {\n    rows,\n    cols,\n    gridData,\n    clues\n  };\n}\nexports.createGridData = createGridData;\nfunction byNumber(a, b) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n  return aNum - bNum;\n}\nexports.byNumber = byNumber;\nfunction clearGuesses(storageKey) {\n  if (!window.localStorage) {\n    return;\n  }\n  window.localStorage.removeItem(storageKey);\n}\nexports.clearGuesses = clearGuesses;\nfunction saveGuesses(gridData, storageKey) {\n  const {\n    localStorage\n  } = window;\n  if (!localStorage) {\n    return;\n  }\n  const guesses = serializeGuesses(gridData);\n  const saveData = {\n    date: Date.now(),\n    guesses\n  };\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\nexports.saveGuesses = saveGuesses;\nfunction serializeGuesses(gridData) {\n  const guesses = gridData.reduce((memo, row, r) => row.reduce((memoInner, cellData, c) => {\n    var _a;\n    const {\n      guess\n    } = cellData;\n    if (guess !== '') {\n      memoInner[`${r}_${c}`] = (_a = cellData.guess) !== null && _a !== void 0 ? _a : '';\n    }\n    return memoInner;\n  }, memo), {});\n  return guesses;\n}\nexports.serializeGuesses = serializeGuesses;\nfunction loadGuesses(gridData, storageKey) {\n  const {\n    localStorage\n  } = window;\n  if (!localStorage) {\n    return;\n  }\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n  const saveData = JSON.parse(saveRaw);\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\nexports.loadGuesses = loadGuesses;\nfunction deserializeGuesses(gridData, guesses) {\n  Object.entries(guesses).forEach(([key, val]) => {\n    const [rStr, cStr] = key.split('_');\n    const r = parseInt(rStr, 10);\n    const c = parseInt(cStr, 10);\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      gridData[r][c].guess = val;\n    }\n  });\n}\nexports.deserializeGuesses = deserializeGuesses;\nfunction findCorrectAnswers(data, gridData) {\n  const correctAnswers = [];\n  exports.bothDirections.forEach(direction => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(([num, info]) => {\n      const {\n        row,\n        col\n      } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if (gridData[r][c].guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n  return correctAnswers;\n}\nexports.findCorrectAnswers = findCorrectAnswers;","map":{"version":3,"names":["directionInfo","across","primary","orthogonal","down","exports","bothDirections","Object","keys","isAcross","direction","otherDirection","calculateExtents","data","dir","primaryMax","orthogonalMax","entries","forEach","info","answer","length","rowColMax","row","col","createEmptyGrid","rows","cols","gridData","Array","r","c","used","fillClues","clues","number","rowStart","colStart","clue","i","cellData","push","sort","byNumber","createGridData","allowNonSquare","acrossMax","downMax","Math","max","size","a","b","aNum","Number","parseInt","bNum","clearGuesses","storageKey","window","localStorage","removeItem","saveGuesses","guesses","serializeGuesses","saveData","date","Date","now","setItem","JSON","stringify","reduce","memo","memoInner","guess","_a","loadGuesses","saveRaw","getItem","parse","deserializeGuesses","key","val","rStr","cStr","split","findCorrectAnswers","correctAnswers","num","correct"],"sources":["C:\\Users\\Nabila\\Desktop\\aksara\\node_modules\\@jaredreisinger\\react-crossword\\src\\util.ts"],"sourcesContent":["import type {\n  AnswerTuple,\n  CellData,\n  CluesData,\n  CluesInput,\n  Direction,\n  GridData,\n  UsedCellData,\n} from './types';\n\ntype RowOrCol = 'row' | 'col';\n\nconst directionInfo: Record<\n  Direction,\n  { primary: RowOrCol; orthogonal: RowOrCol }\n> = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row',\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col',\n  },\n};\n\ninterface RowColMax {\n  row: number;\n  col: number;\n}\n\nexport const bothDirections = Object.keys(directionInfo) as Direction[];\n\nexport function isAcross(direction: Direction) {\n  return direction === 'across';\n}\n\nexport function otherDirection(direction: Direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\n\nexport function calculateExtents(data: CluesInput, direction: Direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n\n  Object.entries(data[direction]).forEach(([, info]) => {\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n\n  const rowColMax: RowColMax = {\n    row: 0,\n    col: 0,\n  };\n\n  rowColMax[dir.primary] = primaryMax;\n  rowColMax[dir.orthogonal] = orthogonalMax;\n\n  return rowColMax;\n}\n\n// const emptyCellData: Partial<CellData> = {\n//   used: false,\n//   // number: undefined, // null,\n//   // answer: '',\n//   // guess: '',\n//   // row: r,\n//   // col: c,\n//   // across: '', //null,\n//   // down: '', //null,\n// } as const;\n\nexport function createEmptyGrid(rows: number, cols: number) {\n  const gridData: GridData = Array(rows);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < rows; r++) {\n    gridData[r] = Array(cols);\n    for (let c = 0; c < cols; c++) {\n      gridData[r][c] = {\n        // ...emptyCellData,\n        row: r,\n        col: c,\n        used: false,\n      };\n    }\n  }\n\n  return gridData;\n}\n\nexport function fillClues(\n  gridData: GridData,\n  clues: CluesData,\n  data: CluesInput,\n  direction: Direction\n) {\n  const dir = directionInfo[direction];\n\n  Object.entries(data[direction]).forEach(([number, info]) => {\n    const { row: rowStart, col: colStart, clue, answer } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === 'row' ? i : 0);\n      const col = colStart + (dir.primary === 'col' ? i : 0);\n      const cellData = gridData[row][col] as UsedCellData;\n\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n\n    clues[direction].push({\n      number,\n      clue,\n      answer,\n      col: colStart,\n      row: rowStart,\n    });\n  });\n\n  clues[direction].sort(byNumber);\n}\n\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nexport function createGridData(data: CluesInput, allowNonSquare?: boolean) {\n  const acrossMax = calculateExtents(data, 'across');\n  const downMax = calculateExtents(data, 'down');\n\n  let rows = Math.max(acrossMax.row, downMax.row) + 1;\n  let cols = Math.max(acrossMax.col, downMax.col) + 1;\n\n  if (!allowNonSquare) {\n    const size = Math.max(rows, cols);\n    rows = size;\n    cols = size;\n  }\n\n  const gridData = createEmptyGrid(rows, cols);\n\n  // Now fill with answers... and also collect the clues\n  const clues: CluesData = {\n    across: [],\n    down: [],\n  };\n\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n\n  return { rows, cols, gridData, clues };\n}\n\n// sort helper for clues...\ninterface HasNumber {\n  number: string;\n}\n\nexport function byNumber(a: HasNumber, b: HasNumber) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n\n  return aNum - bNum;\n}\n\n// Guesses *really* only needs the \"guess\" property...\nexport type GuessData = ({ guess?: string } | CellData)[][];\n\nexport function clearGuesses(storageKey: string) {\n  if (!window.localStorage) {\n    return;\n  }\n\n  window.localStorage.removeItem(storageKey);\n}\n\nexport function saveGuesses(gridData: GuessData, storageKey: string) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const guesses = serializeGuesses(gridData);\n\n  const saveData = {\n    date: Date.now(),\n    guesses,\n  };\n\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\n\nexport function serializeGuesses(gridData: GuessData) {\n  const guesses = gridData.reduce<Record<string, string>>(\n    (memo, row, r) =>\n      row.reduce<Record<string, string>>((memoInner, cellData, c) => {\n        const { guess } = cellData as UsedCellData;\n        if (guess !== '') {\n          memoInner[`${r}_${c}`] = (cellData as UsedCellData).guess ?? '';\n        }\n        return memoInner;\n      }, memo),\n    {}\n  );\n\n  return guesses;\n}\n\nexport function loadGuesses(gridData: GuessData, storageKey: string) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n\n  const saveData = JSON.parse(saveRaw);\n\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\n\nexport function deserializeGuesses(\n  gridData: GuessData,\n  guesses: Record<string, string>\n) {\n  Object.entries(guesses).forEach(([key, val]) => {\n    const [rStr, cStr] = key.split('_');\n    const r = parseInt(rStr, 10);\n    const c = parseInt(cStr, 10);\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      (gridData[r][c] as UsedCellData).guess = val;\n    }\n  });\n}\n\nexport function findCorrectAnswers(data: CluesInput, gridData: GuessData) {\n  const correctAnswers: AnswerTuple[] = [];\n\n  bothDirections.forEach((direction) => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(([num, info]) => {\n      const { row, col } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if ((gridData[r][c] as UsedCellData).guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n\n  return correctAnswers;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}